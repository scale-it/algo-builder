"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runMultipleScripts = exports.splitAfter = void 0;
const debug_1 = __importDefault(require("debug"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const config_env_1 = require("../internal/core/config/config-env");
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
const deployer_1 = require("../internal/deployer");
const tx_log_writer_1 = require("../internal/tx-log-writer");
const lists_1 = require("../internal/util/lists");
const scripts_runner_1 = require("../internal/util/scripts-runner");
const account_1 = require("../lib/account");
const algo_operator_1 = require("../lib/algo-operator");
const asa_1 = require("../lib/asa");
const comparators_1 = require("../lib/comparators");
const files_1 = require("../lib/files");
const script_checkpoints_1 = require("../lib/script-checkpoints");
const task_names_1 = require("./task-names");
function filterNonExistent(scripts) {
    return scripts.filter(script => !fs_extra_1.default.pathExistsSync(script));
}
function mkDeployer(runtimeEnv, cpData, allowWrite, algoOp, asaDefs, accounts, txWriter) {
    const deployer = new deployer_1.AlgobDeployerImpl(runtimeEnv, cpData, asaDefs, algoOp, accounts, txWriter);
    if (allowWrite) {
        return deployer;
    }
    return new deployer_1.AlgobDeployerReadOnlyImpl(deployer, txWriter);
}
// returns all items before the current one and
// mutates the original array to remove them
function splitAfter(scriptsFromScriptsDir, splitAfterScript) {
    for (var i = 0; i < scriptsFromScriptsDir.length; i++) {
        const scriptName = scriptsFromScriptsDir[i];
        if (scriptName === splitAfterScript) {
            return scriptsFromScriptsDir.splice(0, i + 1);
        }
    }
    return scriptsFromScriptsDir.splice(0, scriptsFromScriptsDir.length);
}
exports.splitAfter = splitAfter;
function loadCheckpointsIntoCPData(cpData, scriptPaths) {
    var checkpointData = cpData;
    for (const s of scriptPaths) {
        checkpointData = cpData.merge(script_checkpoints_1.loadCheckpoint(s), s);
    }
    return checkpointData;
}
/** Partitions an unsorted string list into sorted parts:
    `[1 2 2 3 4 3 4 2 1]` returns `[[1 2 2 3 4] [3 4] [2] [1]]` */
function partitionIntoSorted(unsorted) {
    return lists_1.partitionByFn((a, b) => comparators_1.cmpStr(a, b) === 1, // split when a > b
    unsorted);
}
async function runMultipleScripts(runtimeEnv, scriptNames, onSuccessFn, force, logDebugTag, allowWrite, algoOp) {
    const accounts = account_1.mkAccountIndex(runtimeEnv.network.config.accounts);
    const asaDefs = asa_1.loadASAFile(accounts);
    for (const scripts of partitionIntoSorted(scriptNames)) {
        await runSortedScripts(runtimeEnv, scripts, onSuccessFn, force, logDebugTag, allowWrite, algoOp, asaDefs, accounts);
    }
}
exports.runMultipleScripts = runMultipleScripts;
// Function only accepts sorted scripts -- only this way it loads the state correctly.
async function runSortedScripts(runtimeEnv, scriptNames, onSuccessFn, force, logDebugTag, allowWrite, algoOp, asaDefs, accounts) {
    const log = debug_1.default(logDebugTag);
    const cpData = script_checkpoints_1.loadCheckpointsRecursive();
    const txWriter = new tx_log_writer_1.TxWriterImpl('');
    const deployer = mkDeployer(runtimeEnv, cpData, allowWrite, algoOp, asaDefs, accounts, txWriter);
    const scriptsFromScriptsDir = script_checkpoints_1.lsScriptsDir();
    for (const relativeScriptPath of scriptNames) {
        const prevScripts = splitAfter(scriptsFromScriptsDir, relativeScriptPath);
        loadCheckpointsIntoCPData(cpData, prevScripts);
        if (prevScripts[prevScripts.length - 1] !== relativeScriptPath) {
            cpData.merge(script_checkpoints_1.loadCheckpoint(relativeScriptPath), relativeScriptPath);
        }
        if (!force && cpData.networkExistsInCurrentCP(runtimeEnv.network.name)) {
            log(`Skipping: Checkpoint exists for script ${relativeScriptPath}`);
            // '\x1b[33m%s\x1b[0m' this is used for setting the message color to yellow.
            console.warn('\x1b[33m%s\x1b[0m', `Skipping: Checkpoint exists for script ${relativeScriptPath}`);
            continue;
        }
        txWriter.setScriptName(relativeScriptPath);
        log(`Running script ${relativeScriptPath}`);
        await scripts_runner_1.runScript(relativeScriptPath, runtimeEnv, deployer);
        onSuccessFn(cpData, relativeScriptPath);
    }
}
async function executeRunTask({ scripts }, runtimeEnv, algoOp) {
    const logDebugTag = "algob:tasks:run";
    const nonExistent = filterNonExistent(scripts);
    if (nonExistent.length !== 0) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.RUN_FILES_NOT_FOUND, {
            scripts: nonExistent
        });
    }
    await runMultipleScripts(runtimeEnv, files_1.assertDirChildren(script_checkpoints_1.scriptsDirectory, scripts), (_cpData, _relativeScriptPath) => { }, true, logDebugTag, false, algoOp);
}
function default_1() {
    config_env_1.task(task_names_1.TASK_RUN, "Runs a user-defined script after compiling the project")
        .addVariadicPositionalParam("scripts", "A js file to be run within algob's environment")
        .setAction((input, env) => executeRunTask(input, env, algo_operator_1.createAlgoOperator(env.network)));
}
exports.default = default_1;
//# sourceMappingURL=run.js.map