"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAlgorandError = exports.applyErrorMessageTemplate = exports.BuilderPluginError = exports.BuilderError = exports.ERRORS = void 0;
const caller_package_1 = require("../util/caller-package");
const strings_1 = require("../util/strings");
const errors_list_1 = require("./errors-list");
Object.defineProperty(exports, "ERRORS", { enumerable: true, get: function () { return errors_list_1.ERRORS; } });
// For an explanation about these classes constructors go to:
// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
class BuilderError extends Error {
    constructor(errorDescriptor, messageArguments = {}, parentError) {
        const prefix = `${errors_list_1.getErrorCode(errorDescriptor)}: `;
        const formattedMessage = applyErrorMessageTemplate(errorDescriptor.message, messageArguments);
        super(prefix + formattedMessage);
        this.errorDescriptor = errorDescriptor;
        this.number = errorDescriptor.number;
        if (parentError instanceof Error) {
            this.parent = parentError;
        }
        this._isBuilderError = true;
        Object.setPrototypeOf(this, BuilderError.prototype);
    }
    static isBuilderError(other) {
        return (other !== undefined && other !== null && other._isBuilderError === true);
    }
}
exports.BuilderError = BuilderError;
/**
 * This class is used to throw errors from algob plugins.
 */
class BuilderPluginError extends Error {
    constructor(pluginNameOrMessage, messageOrParent, parent) {
        if (typeof messageOrParent === "string") {
            super(messageOrParent);
            this.pluginName = pluginNameOrMessage;
            this.parent = parent;
        }
        else {
            super(pluginNameOrMessage);
            this.pluginName = caller_package_1.getClosestCallerPackage();
            this.parent = messageOrParent;
        }
        this._isBuilderPluginError = true;
        Object.setPrototypeOf(this, BuilderPluginError.prototype);
    }
    static isBuilderPluginError(other) {
        return (other !== undefined &&
            other !== null &&
            other._isBuilderPluginError === true);
    }
}
exports.BuilderPluginError = BuilderPluginError;
/**
 * This function applies error messages templates like this:
 *
 *  - Template is a string which contains a variable tags. A variable tag is a
 *    a variable name surrounded by %. Eg: %plugin1%
 *  - A variable name is a string of alphanumeric ascii characters.
 *  - Every variable tag is replaced by its value.
 *  - %% is replaced by %.
 *  - Values can't contain variable tags.
 *  - If a variable is not present in the template, but present in the values
 *    object, an error is thrown.
 *
 * @param template The template string.
 * @param values A map of variable names to their values.
 */
function applyErrorMessageTemplate(template, values // eslint-disable-line @typescript-eslint/no-explicit-any
) {
    return _applyErrorMessageTemplate(template, values, false);
}
exports.applyErrorMessageTemplate = applyErrorMessageTemplate;
function _applyErrorMessageTemplate(template, values, // eslint-disable-line @typescript-eslint/no-explicit-any
isRecursiveCall) {
    // if (!isRecursiveCall) {
    //  for (const variableName of Object.keys(values)) {
    //    if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {
    //      throw new BuilderError(ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {
    //        variable: variableName,
    //      });
    //    }
    //    const variableTag = `%${variableName}%`;
    //    if (!template.includes(variableTag)) {
    //      throw new BuilderError(ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {
    //        variable: variableName,
    //      });
    //    }
    //  }
    // }
    if (template.includes("%%")) {
        return template
            .split("%%")
            .map((part) => _applyErrorMessageTemplate(part, values, true))
            .join("%");
    }
    for (const variableName of Object.keys(values)) {
        let value;
        if (values[variableName] === undefined) {
            value = "undefined";
        }
        else if (values[variableName] === null) {
            value = "null";
        }
        else {
            value = values[variableName].toString();
        }
        if (value === undefined) {
            value = "undefined";
        }
        const variableTag = `%${variableName}%`;
        // if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {
        //  throw new BuilderError(
        //    ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG,
        //    { variable: variableName }
        //  );
        // }
        template = strings_1.replaceAll(template, variableTag, value);
    }
    return template;
}
function parseAlgorandError(e, ctx) {
    var _a, _b;
    if (e === undefined) {
        return new BuilderError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING);
    }
    if ((e === null || e === void 0 ? void 0 : e.statusCode) !== undefined) {
        if (e.statusCode >= 400 && e.statusCode < 500) {
            return new BuilderError(errors_list_1.ERRORS.ALGORAND.BAD_REQUEST, {
                status: e.statusCode,
                message: (_b = (_a = e.body) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : e.text,
                ctx: JSON.stringify(ctx)
            }, e.error);
        }
        return new BuilderError(errors_list_1.ERRORS.ALGORAND.INTERNAL_ERROR, {
            status: e.statusCode
        }, e);
    }
    return e;
}
exports.parseAlgorandError = parseAlgorandError;
//# sourceMappingURL=errors.js.map