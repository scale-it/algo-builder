"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorPutter = exports.mkErrorMessage = void 0;
const lib_1 = require("io-ts/lib");
function stringify(v) {
    if (typeof v === "function") {
        return lib_1.getFunctionName(v);
    }
    if (typeof v === "number" && !isFinite(v)) {
        if (isNaN(v)) {
            return "NaN";
        }
        return v > 0 ? "Infinity" : "-Infinity";
    }
    return JSON.stringify(v);
}
function mkErrorMessage(path, value, expectedType) {
    return `Invalid value ${stringify(value)} for ${path} - Expected a value of type ${expectedType}.`;
}
exports.mkErrorMessage = mkErrorMessage;
class CfgErrors {
    constructor(prefix = "config.networks") {
        this.errors = [];
        this.prefix = prefix;
    }
    push(net, field, val, expectedType) {
        this.errors.push(mkErrorMessage(`${this.prefix}.${net}.${field}`, val, expectedType));
    }
    concatenate(errors) {
        for (const e of errors) {
            this.errors.push(e);
        }
    }
    isEmpty() {
        return this.errors.length === 0;
    }
    toString() {
        return this.errors.join("\n  * ");
    }
    putter(net, field) {
        return new ErrorPutter(this, net, field);
    }
}
exports.default = CfgErrors;
class ErrorPutter {
    constructor(errs, net, field) {
        this.isEmpty = true;
        this.errs = errs;
        this.net = net;
        this.field = field;
    }
    // wraps CfgErrors.put and always returns false.
    push(field, val, expectedType) {
        if (field === "") {
            field = this.field;
        }
        else {
            field = this.field + "." + field;
        }
        this.errs.push(this.net, field, val, expectedType);
        this.isEmpty = false;
        return false;
    }
}
exports.ErrorPutter = ErrorPutter;
//# sourceMappingURL=config-errors.js.map