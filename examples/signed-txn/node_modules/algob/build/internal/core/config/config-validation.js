"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidationErrors = exports.validateConfig = exports.DotPathReporter = exports.success = exports.failure = void 0;
const Either_1 = require("fp-ts/lib/Either");
const pipeable_1 = require("fp-ts/lib/pipeable");
const t = __importStar(require("io-ts"));
const account_1 = require("../../../lib/account");
const constants_1 = require("../../constants");
const errors_1 = require("../errors");
const errors_list_1 = require("../errors-list");
const config_errors_1 = __importStar(require("./config-errors"));
function getContextPath(context) {
    const keysPath = context
        .slice(1)
        .map((c) => c.key)
        .join(".");
    return `${context[0].type.name}.${keysPath}`;
}
function getMessage(e) {
    const lastContext = e.context[e.context.length - 1];
    return e.message !== undefined
        ? e.message
        : config_errors_1.mkErrorMessage(getContextPath(e.context), e.value, lastContext.type.name);
}
function failure(es) {
    return es.map(getMessage);
}
exports.failure = failure;
function success() {
    return [];
}
exports.success = success;
exports.DotPathReporter = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    report: (validation) => pipeable_1.pipe(validation, Either_1.fold(failure, success))
};
function optional(codec, name = `${codec.name} | undefined`) {
    return new t.Type(name, (u) => u === undefined || codec.is(u), (u, c) => (u === undefined ? t.success(u) : codec.validate(u, c)), // eslint-disable-line @typescript-eslint/no-explicit-any
    (a) => (a === undefined ? undefined : codec.encode(a)) // eslint-disable-line @typescript-eslint/no-explicit-any
    );
}
// IMPORTANT: This t.types MUST be kept in sync with the actual types.
const AccountType = t.type({
    addr: t.string,
    // TODO: unsure how to handle Uint8Array type here. Instead we are doing it
    // in the validation method below.
    sk: t.unknown,
    name: t.string
});
const AlgobChainType = t.type({
    accounts: optional(t.array(AccountType)),
    chainName: optional(t.string),
    throwOnTransactionFailures: optional(t.boolean),
    throwOnCallFailures: optional(t.boolean),
    loggingEnabled: optional(t.boolean),
    initialDate: optional(t.string)
});
const HttpHeaders = t.record(t.string, t.string, "httpHeaders");
const HttpNetworkType = t.type({
    accounts: optional(t.array(AccountType)),
    chainName: optional(t.string),
    // from: optional(t.string),
    host: optional(t.string),
    port: optional(t.number),
    token: optional(t.string),
    httpHeaders: optional(HttpHeaders)
});
const NetworkType = t.union([AlgobChainType, HttpNetworkType]);
const NetworksType = t.record(t.string, NetworkType);
const ProjectPaths = t.type({
    root: optional(t.string),
    cache: optional(t.string),
    artifacts: optional(t.string),
    sources: optional(t.string),
    tests: optional(t.string)
});
const Config = t.type({
    networks: optional(NetworksType),
    paths: optional(ProjectPaths)
}, "AlgobConfig");
/**
 * Validates the config, throwing a BuilderError if invalid.
 * @param config
 */
function validateConfig(config) {
    const errors = getValidationErrors(config);
    if (errors.isEmpty()) {
        return;
    }
    const errorList = `  * ${errors.toString()}`;
    throw new errors_1.BuilderError(errors_list_1.ERRORS.GENERAL.INVALID_CONFIG, { errors: errorList });
}
exports.validateConfig = validateConfig;
function getValidationErrors(config) {
    const errors = new config_errors_1.default();
    // These can't be validated with io-ts
    if (config !== undefined && typeof config.networks === "object") {
        for (const [net, ncfg] of Object.entries(config.networks)) {
            const accountsMap = new Map(); // {} as ([key: string]: number);
            let j;
            for (let i = 0; i < (ncfg.accounts || []).length; ++i) {
                const a = ncfg.accounts[i];
                const p = errors.putter(net + ".accounts", i.toString());
                account_1.validateAccount(a, p);
                if ((j = accountsMap.get(a.name)) !== undefined) {
                    p.push('name', `Account name ${a.name} already exists at index ${j}`, 'string');
                }
                else {
                    accountsMap.set(a.name, i);
                }
            }
            // ONLY AlgobChain network can be of type AlgobChainCfg
            if (net === constants_1.ALGOB_CHAIN_NAME) {
                validateAlgobChainCfg(ncfg, errors);
                continue;
            }
            const hcfg = ncfg;
            const host = hcfg.host;
            if (typeof host !== "string" || host === "" || !validateHostname(host)) {
                errors.push(net, "host", host, "hostname string (eg: http://example.com)");
            }
            const token = hcfg.token;
            if (typeof token !== "string" || token.length < 10) {
                errors.push(net, "token", token, "string");
            }
            const netConfigResult = HttpNetworkType.decode(hcfg);
            if (Either_1.isLeft(netConfigResult)) {
                errors.push(net, "", hcfg, "HttpNetworkConfig");
            }
        }
    }
    // io-ts can get confused if there are errors that it can't understand.
    // It will treat networks as an HTTPConfig and may give a loot of errors.
    if (!errors.isEmpty()) {
        return errors;
    }
    const result = Config.decode(config);
    if (Either_1.isRight(result)) {
        return errors;
    }
    errors.concatenate(exports.DotPathReporter.report(result));
    return errors;
}
exports.getValidationErrors = getValidationErrors;
function validateAlgobChainCfg(ncfg, errors) {
    const tBoolOpt = "boolean | undefined";
    if (ncfg.initialDate !== undefined &&
        typeof ncfg.initialDate !== "string") {
        errors.push(constants_1.ALGOB_CHAIN_NAME, "initialDate", ncfg.initialDate, "string | undefined");
    }
    if (ncfg.throwOnTransactionFailures !== undefined &&
        typeof ncfg.throwOnTransactionFailures !== "boolean") {
        errors.push(constants_1.ALGOB_CHAIN_NAME, "throwOnTransactionFailures", ncfg.throwOnTransactionFailures, tBoolOpt);
    }
    if (ncfg.throwOnCallFailures !== undefined &&
        typeof ncfg.throwOnCallFailures !== "boolean") {
        errors.push(constants_1.ALGOB_CHAIN_NAME, "throwOnCallFailures", ncfg.throwOnCallFailures, tBoolOpt);
    }
    const host = ncfg.host;
    if (host !== undefined) {
        errors.push(constants_1.ALGOB_CHAIN_NAME, "host", host, "null (forbidden)");
    }
    if (ncfg.chainName !== undefined &&
        typeof ncfg.chainName !== "string") {
        errors.push(constants_1.ALGOB_CHAIN_NAME, "chainName", ncfg.chainName, "string | undefined");
    }
    if (ncfg.loggingEnabled !== undefined &&
        typeof ncfg.loggingEnabled !== "boolean") {
        errors.push(constants_1.ALGOB_CHAIN_NAME, "loggingEnabled", ncfg.loggingEnabled, tBoolOpt);
    }
}
// this comes from https://stackoverflow.com/questions/5717093
const hostPattern = new RegExp('^(https?:\\/\\/)?' + // protocol
    '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // domain name
    '(localhost)|' + // localhost
    '((\\d{1,3}\\.){3}\\d{1,3}))'); // OR ip (v4) address
function validateHostname(str) {
    return !!hostPattern.test(str);
}
//# sourceMappingURL=config-validation.js.map