#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadEnvironmentAndArgs = exports.gatherArguments = void 0;
// -*- mode: typescript -*- // https://github.com/syl20bnr/spacemacs/issues/13715
require("source-map-support/register");
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const semver_1 = __importDefault(require("semver"));
const task_names_1 = require("../../builtin-tasks/task-names");
const exceptions_1 = require("../../lib/exceptions");
const constants_1 = require("../constants");
const context_1 = require("../context");
const config_loading_1 = require("../core/config/config-loading");
const errors_1 = require("../core/errors");
const errors_list_1 = require("../core/errors-list");
const builder_params_1 = require("../core/params/builder-params");
const env_variables_1 = require("../core/params/env-variables");
const project_structure_1 = require("../core/project-structure");
const runtime_environment_1 = require("../core/runtime-environment");
const builtin_tasks_1 = require("../core/tasks/builtin-tasks");
const package_info_1 = require("../util/package-info");
// import { Analytics } from "./analytics";
const arguments_parser_1 = require("./arguments-parser");
const log = debug_1.default("algob:core:cli");
// const ANALYTICS_SLOW_TASK_THRESHOLD = 300;
async function printVersionMessage(packageJson) {
    console.log(packageJson.version);
}
function ensureValidNodeVersion(packageJson) {
    const requirement = packageJson.engines.node;
    if (!semver_1.default.satisfies(process.version, requirement)) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.GENERAL.INVALID_NODE_VERSION, {
            requirement
        });
    }
}
function printErrRecur(error) {
    if (error.parent) {
        if (error.parent instanceof errors_1.BuilderError) {
            printErrRecur(error.parent);
        }
        else {
            console.error(error.parent);
        }
    }
}
function printStackTraces(showStackTraces, error) {
    if (error === undefined) {
        return;
    }
    if (showStackTraces) {
        printErrRecur(error);
    }
    else {
        console.error(`For more info run ${constants_1.ALGOB_NAME} with --show-stack-traces or add --help to display task-specific help.`);
    }
}
async function gatherArguments() {
    // We first accept this argument anywhere, so we know if the user wants
    // stack traces before really parsing the arguments.
    let showStackTraces = process.argv.includes("--show-stack-traces");
    const packageJson = await package_info_1.getPackageJson();
    ensureValidNodeVersion(packageJson);
    const envVariableArguments = env_variables_1.getEnvRuntimeArgs(builder_params_1.ALGOB_PARAM_DEFINITIONS, process.env);
    const argumentsParser = new arguments_parser_1.ArgumentsParser();
    const { runtimeArgs, taskName: maybeTaskName, unparsedCLAs } = argumentsParser.parseRuntimeArgs(builder_params_1.ALGOB_PARAM_DEFINITIONS, builder_params_1.ALGOB_SHORT_PARAM_SUBSTITUTIONS, envVariableArguments, process.argv.slice(2));
    if (runtimeArgs.verbose) {
        debug_1.default.enable("algob*");
    }
    showStackTraces = runtimeArgs.showStackTraces;
    return {
        runtimeArgs: runtimeArgs,
        unparsedCLAs: unparsedCLAs,
        maybeTaskName: maybeTaskName,
        showStackTraces: showStackTraces,
        packageJson: packageJson,
        argumentsParser: argumentsParser
    };
}
exports.gatherArguments = gatherArguments;
async function loadEnvironmentAndArgs(maybeTaskName, runtimeArgs, argumentsParser, unparsedCLAs) {
    const ctx = context_1.BuilderContext.createBuilderContext();
    const config = config_loading_1.loadConfigAndTasks(runtimeArgs);
    const envExtenders = ctx.extendersManager.getExtenders();
    const taskDefinitions = ctx.tasksDSL.getTaskDefinitions();
    let taskName = maybeTaskName !== null && maybeTaskName !== void 0 ? maybeTaskName : task_names_1.TASK_HELP;
    if (taskDefinitions[taskName] == null) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {
            task: taskName
        });
    }
    const origTaskName = taskName;
    // --help is a also special case
    let taskArguments;
    if (runtimeArgs.help && taskName !== task_names_1.TASK_HELP) {
        taskArguments = { task: taskName };
        taskName = task_names_1.TASK_HELP;
    }
    else {
        taskArguments = argumentsParser.parseTaskArguments(taskDefinitions[taskName], unparsedCLAs);
    }
    // we can't do it earlier because we above we need to check the special case with `--help`
    const isSetup = builtin_tasks_1.isSetupTask(taskName);
    // Being inside of a project is non-mandatory for help and init
    if (!isSetup && !project_structure_1.isCwdInsideProject()) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.GENERAL.NOT_INSIDE_PROJECT, { task: origTaskName });
    }
    const env = new runtime_environment_1.Environment(config, runtimeArgs, taskDefinitions, envExtenders, !isSetup);
    ctx.setAlgobRuntimeEnv(env);
    return {
        env: env,
        taskName: taskName,
        taskArguments: taskArguments
    };
}
exports.loadEnvironmentAndArgs = loadEnvironmentAndArgs;
/* eslint-disable sonarjs/cognitive-complexity */
async function main() {
    var _a;
    // const analytics = await Analytics.getInstance(
    //  config.paths.root,
    //  config.analytics.enabled
    // );
    var showStackTraces = false;
    try {
        const { runtimeArgs, unparsedCLAs, showStackTraces: showStackTracesUpdate, packageJson, maybeTaskName, argumentsParser } = await gatherArguments();
        showStackTraces = showStackTracesUpdate;
        // --version is a special case
        if (runtimeArgs.version) {
            await printVersionMessage(packageJson);
            return;
        }
        const { env, taskName, taskArguments } = await loadEnvironmentAndArgs(maybeTaskName, runtimeArgs, argumentsParser, unparsedCLAs);
        // let [abortAnalytics, hitPromise] = await analytics.sendTaskHit(taskName);
        // const tBeforeRun = new Date().getTime();
        try {
            await env.run(taskName, taskArguments);
        }
        catch (e) {
            if (!exceptions_1.checkAlgorandUnauthorized(e, env.network)) {
                throw e;
            }
        }
        // const tAfterRun = new Date().getTime();
        // if (tAfterRun - tBeforeRun > ANALYTICS_SLOW_TASK_THRESHOLD) {
        //  await hitPromise;
        // } else {
        //  abortAnalytics();
        // }
        log(`Quitting algob after successfully running task ${taskName}`);
    }
    catch (error) {
        if (errors_1.BuilderError.isBuilderError(error)) {
            console.error(chalk_1.default.red(`Error ${error.message}`));
        }
        else if (errors_1.BuilderPluginError.isBuilderPluginError(error)) {
            console.error(chalk_1.default.red(`Error in plugin ${(_a = error.pluginName) !== null && _a !== void 0 ? _a : ""}: ${error.message}`));
        }
        else if (error instanceof Error) {
            console.error(chalk_1.default.red("An unexpected error occurred:"), error.message);
            showStackTraces = true;
        }
        else {
            console.error(chalk_1.default.red("An unexpected error occurred."));
            showStackTraces = true;
        }
        console.log("");
        printStackTraces(showStackTraces, error);
        process.exit(1);
    }
}
main()
    .then(() => process.exit(process.exitCode))
    .catch((error) => {
    console.error(error);
    process.exit(1);
});
//# sourceMappingURL=cli.js.map