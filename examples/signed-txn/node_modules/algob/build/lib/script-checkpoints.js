"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadCheckpointsRecursive = exports.lsScriptsDir = exports.loadCheckpoint = exports.loadCheckpointByCPName = exports.toMap = exports.persistCheckpoint = exports.CheckpointRepoImpl = exports.appendToCheckpoint = exports.CheckpointImpl = exports.registerASC = exports.registerASA = exports.toScriptFileName = exports.toCheckpointFileName = exports.scriptsDirectory = void 0;
const deep_equal_1 = __importDefault(require("deep-equal"));
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
const files_1 = require("./files");
exports.scriptsDirectory = "scripts";
const artifactsPath = "artifacts";
const checkpointFileSuffix = ".cp.yaml";
function toCheckpointFileName(scriptName) {
    return path_1.default.join(artifactsPath, scriptName + checkpointFileSuffix);
}
exports.toCheckpointFileName = toCheckpointFileName;
function toScriptFileName(filename) {
    filename = filename.replace(artifactsPath + path_1.default.sep, '');
    filename = filename.slice(0, -(checkpointFileSuffix.length));
    return filename;
}
exports.toScriptFileName = toScriptFileName;
function registerASA(cp, name, info) {
    cp.asa.set(name, info);
    return cp;
}
exports.registerASA = registerASA;
function registerASC(cp, name, info) {
    cp.asc.set(name, info);
    return cp;
}
exports.registerASC = registerASC;
class CheckpointImpl {
    constructor(metadata) {
        this.timestamp = +new Date();
        this.metadata = (metadata === undefined ? new Map() : metadata);
        this.asa = new Map();
        this.asc = new Map();
    }
}
exports.CheckpointImpl = CheckpointImpl;
function appendToCheckpoint(checkpoints, networkName, append) {
    var _a;
    const orig = checkpoints[networkName];
    if (!orig) {
        checkpoints[networkName] = Object.assign({}, append);
        return checkpoints;
    }
    orig.timestamp = append.timestamp;
    orig.metadata = new Map([...orig.metadata, ...append.metadata]);
    const allAssetNames = [...append.asa.keys(), ...append.asc.keys()];
    for (const assetName of allAssetNames) {
        if ((_a = (orig.asa.get(assetName) && !deep_equal_1.default(orig.asa.get(assetName), append.asa.get(assetName)))) !== null && _a !== void 0 ? _a : (orig.asc.get(assetName) && !deep_equal_1.default(orig.asc.get(assetName), append.asc.get(assetName)))) {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.CHECKPOINT_ERROR_DUPLICATE_ASSET_DEFINITION, { assetName: assetName });
        }
    }
    orig.asa = new Map([...orig.asa, ...append.asa]);
    orig.asc = new Map([...orig.asc, ...append.asc]);
    return checkpoints;
}
exports.appendToCheckpoint = appendToCheckpoint;
class CheckpointRepoImpl {
    constructor() {
        this.strippedCP = {};
        this.precedingCP = {};
        this.allCPs = {};
        this.scriptMap = {};
    }
    _mergeTo(target, cp, scriptMap) {
        const keys = Object.keys(cp);
        return keys.reduce((out, key) => {
            return appendToCheckpoint(out, key, cp[key]);
        }, target);
    }
    merge(cp, scriptName) {
        this.strippedCP = cp;
        this.precedingCP = this._mergeTo(this.precedingCP, cp, this.scriptMap);
        this.mergeToGlobal(cp, scriptName);
        return this;
    }
    mergeToGlobal(cp, scriptName) {
        const keys = Object.keys(cp);
        for (const k of keys) {
            const current = cp[k];
            const allAssetNames = [...current.asa.keys(), ...current.asc.keys()];
            for (const assetName of allAssetNames) {
                if (!(this.scriptMap[assetName])) {
                    this.scriptMap[assetName] = scriptName;
                }
                else {
                    if (this.scriptMap[assetName] !== scriptName) {
                        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.CHECKPOINT_ERROR_DUPLICATE_ASSET_DEFINITION, { assetName: [this.scriptMap[assetName], scriptName] });
                    }
                }
            }
        }
        this.allCPs = this._mergeTo(this.allCPs, cp, this.scriptMap);
        return this;
    }
    _ensureNet(cp, networkName) {
        if (!cp[networkName]) {
            cp[networkName] = new CheckpointImpl();
        }
        return cp[networkName];
    }
    putMetadata(networkName, key, value) {
        this._ensureNet(this.allCPs, networkName).metadata.set(key, value);
        this._ensureNet(this.strippedCP, networkName).metadata.set(key, value);
        this._ensureNet(this.precedingCP, networkName).metadata.set(key, value);
        return this;
    }
    getMetadata(networkName, key) {
        if (this.precedingCP[networkName]) {
            return this.precedingCP[networkName].metadata.get(key);
        }
        return undefined;
    }
    registerASA(networkName, name, info) {
        registerASA(this._ensureNet(this.precedingCP, networkName), name, info);
        registerASA(this._ensureNet(this.strippedCP, networkName), name, info);
        registerASA(this._ensureNet(this.allCPs, networkName), name, info);
        return this;
    }
    registerASC(networkName, name, info) {
        registerASC(this._ensureNet(this.precedingCP, networkName), name, info);
        registerASC(this._ensureNet(this.strippedCP, networkName), name, info);
        registerASC(this._ensureNet(this.allCPs, networkName), name, info);
        return this;
    }
    isDefined(networkName, name) {
        const netCP = this.allCPs[networkName];
        return netCP !== undefined &&
            (netCP.asa.get(name) !== undefined || netCP.asc.get(name) !== undefined);
    }
    networkExistsInCurrentCP(networkName) {
        return Boolean(this.strippedCP[networkName]);
    }
}
exports.CheckpointRepoImpl = CheckpointRepoImpl;
function persistCheckpoint(scriptName, checkpoint) {
    const scriptPath = toCheckpointFileName(scriptName);
    const scriptDir = path_1.default.dirname(scriptPath);
    fs.mkdirSync(scriptDir, { recursive: true });
    fs.writeFileSync(scriptPath, yaml_1.default.stringify(checkpoint));
}
exports.persistCheckpoint = persistCheckpoint;
// http://xahlee.info/js/js_object_to_map_datatype.html
function toMap(obj) {
    const mp = new Map();
    Object.keys(obj).forEach(k => { mp.set(k, obj[k]); });
    return mp;
}
exports.toMap = toMap;
;
function convertCPValsToMaps(cpWithObjects) {
    cpWithObjects.asa = toMap(cpWithObjects.asa);
    cpWithObjects.asc = toMap(cpWithObjects.asc);
    cpWithObjects.metadata = toMap(cpWithObjects.metadata);
    return cpWithObjects;
}
function loadCheckpointByCPName(checkpointName) {
    // Some structures are objects, some others are maps. Oh why.
    const checkpoints = files_1.loadFromYamlFileSilent(checkpointName, { mapAsMap: false });
    for (const k of Object.keys(checkpoints)) {
        convertCPValsToMaps(checkpoints[k]);
    }
    return checkpoints;
}
exports.loadCheckpointByCPName = loadCheckpointByCPName;
function loadCheckpoint(scriptName) {
    return loadCheckpointByCPName(toCheckpointFileName(scriptName));
}
exports.loadCheckpoint = loadCheckpoint;
function lsTreeWalk(directoryName) {
    var list = [];
    fs.readdirSync(directoryName).forEach(file => {
        var fullPath = path_1.default.join(directoryName, file);
        const f = fs.statSync(fullPath);
        if (f.isDirectory()) {
            list = list.concat(lsTreeWalk(fullPath));
        }
        else {
            list.push(fullPath);
        }
    });
    return list;
}
;
function lsFiles(directoryName) {
    var list = [];
    fs.readdirSync(directoryName).forEach(file => {
        var fullPath = path_1.default.join(directoryName, file);
        const f = fs.statSync(fullPath);
        if (f.isFile()) {
            list.push(fullPath);
        }
    });
    return list;
}
;
function ensureCheckpointsPath() {
    const checkpointsPath = path_1.default.join(".", artifactsPath, exports.scriptsDirectory);
    fs.mkdirSync(checkpointsPath, { recursive: true });
    return checkpointsPath;
}
function findCheckpointsRecursive() {
    return lsTreeWalk(ensureCheckpointsPath())
        .filter(filename => filename.endsWith(checkpointFileSuffix));
}
function lsScriptsDir() {
    return lsFiles(exports.scriptsDirectory);
}
exports.lsScriptsDir = lsScriptsDir;
function loadCheckpointsRecursive() {
    return findCheckpointsRecursive().reduce((out, filename) => {
        return out.mergeToGlobal(loadCheckpointByCPName(filename), toScriptFileName(filename));
    }, new CheckpointRepoImpl());
}
exports.loadCheckpointsRecursive = loadCheckpointsRecursive;
//# sourceMappingURL=script-checkpoints.js.map