"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFromYamlFileSilentWithMessage = exports.loadFromYamlFileSilent = exports.assertDirectDirChildren = exports.assertDirChildren = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
function normalizePaths(mainPath, paths) {
    return paths.map(n => path_1.default.relative(mainPath, n));
}
function assertDirChildren(dir, scriptNames) {
    const normalized = normalizePaths(".", scriptNames);
    const nonScriptPaths = normalized
        .filter(scriptName => !path_1.default.relative(".", scriptName).startsWith(dir));
    if (nonScriptPaths.length !== 0) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.SCRIPTS_OUTSIDE_SCRIPTS_DIRECTORY, {
            scripts: nonScriptPaths
        });
    }
    return normalized;
}
exports.assertDirChildren = assertDirChildren;
function assertDirectDirChildren(dir, scriptNames) {
    const normalized = normalizePaths(".", scriptNames);
    const badPaths = normalized.filter(scriptName => path_1.default.dirname(scriptName) !== dir);
    if (badPaths.length !== 0) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOY_SCRIPT_NON_DIRECT_CHILD, {
            scripts: badPaths
        });
    }
    return normalized;
}
exports.assertDirectDirChildren = assertDirectDirChildren;
function readYAML(filePath, options) {
    return yaml_1.default.parse(fs_1.default.readFileSync(filePath).toString(), options);
}
function defaultYamlValue(options) {
    if (options === null || options === void 0 ? void 0 : options.mapAsMap) {
        return new Map();
    }
    return {};
}
function loadFromYamlFileSilent(filePath, options) {
    // Try-catch is the way:
    // https://nodejs.org/docs/latest/api/fs.html#fs_fs_stat_path_options_callback
    // Instead, user code should open/read/write the file directly and
    // handle the error raised if the file is not available
    try {
        return readYAML(filePath, options);
    }
    catch (e) {
        return defaultYamlValue(options);
    }
}
exports.loadFromYamlFileSilent = loadFromYamlFileSilent;
function loadFromYamlFileSilentWithMessage(filePath, messageIfNotPresent, options) {
    try {
        return readYAML(filePath, options);
    }
    catch (e) {
        console.warn(messageIfNotPresent);
        return defaultYamlValue(options);
    }
}
exports.loadFromYamlFileSilentWithMessage = loadFromYamlFileSilentWithMessage;
//# sourceMappingURL=files.js.map