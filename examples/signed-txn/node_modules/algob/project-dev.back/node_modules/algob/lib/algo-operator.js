"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgoOperatorImpl = exports.createAlgoOperator = exports.ALGORAND_MIN_TX_FEE = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
const driver_1 = require("../lib/driver");
const compile_1 = require("./compile");
const tx = __importStar(require("./tx"));
const confirmedRound = "confirmed-round";
// This was not exported in algosdk
exports.ALGORAND_MIN_TX_FEE = 1000;
// Extracted from interaction with Algorand node (100k microAlgos)
const ALGORAND_ASA_OWNERSHIP_COST = 100000;
function createAlgoOperator(network) {
    return new AlgoOperatorImpl(driver_1.createClient(network));
}
exports.createAlgoOperator = createAlgoOperator;
class AlgoOperatorImpl {
    constructor(algocl) {
        this.algodClient = algocl;
        this.compileOp = new compile_1.CompileOp(this.algodClient);
    }
    // Source:
    // https://github.com/algorand/docs/blob/master/examples/assets/v2/javascript/AssetExample.js#L21
    // Function used to wait for a tx confirmation
    async waitForConfirmation(txId) {
        const response = await this.algodClient.status().do();
        let lastround = response["last-round"];
        while (true) {
            const pendingInfo = await this.algodClient.pendingTransactionInformation(txId).do();
            if (pendingInfo[confirmedRound] !== null && pendingInfo[confirmedRound] > 0) {
                return pendingInfo;
            }
            lastround++;
            await this.algodClient.statusAfterBlock(lastround).do();
        }
    }
    ;
    getTxFee(params, txSize) {
        if (params.flatFee) {
            return Math.max(exports.ALGORAND_MIN_TX_FEE, params.fee);
        }
        return Math.max(exports.ALGORAND_MIN_TX_FEE, txSize);
    }
    getUsableAccBalance(accoutInfo) {
        // Extracted from interacting with Algorand node:
        // 7 opted-in assets require to have 800000 micro algos (frozen in account).
        // 11 assets require 1200000.
        return accoutInfo.amount - (accoutInfo.assets.length + 1) * ALGORAND_ASA_OWNERSHIP_COST;
    }
    getOptInTxSize(params, accounts) {
        const randomAccount = accounts.values().next().value;
        // assetID can't be known before ASA creation
        // it shouldn't be easy to find out the latest asset ID
        // In original source code it's uint64:
        // https://github.com/algorand/go-algorand/blob/1424855ad2b5f6755ff3feba7e419ee06f2493da/data/basics/userBalance.go#L278
        const assetID = Number.MAX_SAFE_INTEGER; // not 64 bits but 55 bits should be enough
        const sampleASAOptInTX = tx.makeASAOptInTx(randomAccount.addr, assetID, params);
        const rawSignedTxn = sampleASAOptInTX.signTxn(randomAccount.sk);
        return rawSignedTxn.length;
    }
    async _optInToASA(asaName, assetIndex, account, params) {
        console.log(`ASA ${account.name} opt-in for for ASA ${asaName}`);
        const sampleASAOptInTX = tx.makeASAOptInTx(account.addr, assetIndex, params);
        const rawSignedTxn = sampleASAOptInTX.signTxn(account.sk);
        const txInfo = await this.algodClient.sendRawTransaction(rawSignedTxn).do();
        await this.waitForConfirmation(txInfo.txId);
    }
    async optInToASA(asaName, assetIndex, account, flags) {
        const txParams = await tx.mkSuggestedParams(this.algodClient, flags);
        await this._optInToASA(asaName, assetIndex, account, txParams);
    }
    async optInToASAMultiple(asaName, assetIndex, accounts, params) {
        for (const account of accounts) {
            await this._optInToASA(asaName, assetIndex, account, params);
        }
    }
    async checkBalanceForOptInTx(name, params, asaDef, accounts, creator) {
        if (!asaDef.optInAccNames || asaDef.optInAccNames.length === 0) {
            return [];
        }
        const optInTxFee = this.getTxFee(params, this.getOptInTxSize(params, accounts));
        const optInAccs = [];
        for (const accName of asaDef.optInAccNames) {
            const account = accounts.get(accName);
            if (!account) {
                throw new errors_1.BuilderError(errors_list_1.ERRORS.SCRIPT.ASA_OPT_IN_ACCOUNT_NOT_FOUND, {
                    accountName: accName
                });
            }
            optInAccs.push(account);
            if (account.addr === creator.addr) {
                throw new errors_1.BuilderError(errors_list_1.ERRORS.SCRIPT.ASA_TRIED_TO_OPT_IN_CREATOR);
            }
            const accountInfo = await this.algodClient.accountInformation(account.addr).do();
            const requiredAmount = optInTxFee + ALGORAND_ASA_OWNERSHIP_COST;
            const usableAmount = this.getUsableAccBalance(accountInfo);
            if (usableAmount < requiredAmount) {
                throw new errors_1.BuilderError(errors_list_1.ERRORS.SCRIPT.ASA_OPT_IN_ACCOUNT_INSUFFICIENT_BALANCE, {
                    accountName: accName,
                    balance: usableAmount,
                    requiredBalance: requiredAmount,
                    asaName: name
                });
            }
        }
        return optInAccs;
    }
    async deployASA(name, asaDef, flags, accounts, txWriter) {
        const message = 'Deploying ASA: ' + name;
        console.log(message);
        const txParams = await tx.mkSuggestedParams(this.algodClient, flags);
        const optInAccounts = await this.checkBalanceForOptInTx(name, txParams, asaDef, accounts, flags.creator);
        const assetTX = tx.makeAssetCreateTxn(name, asaDef, flags, txParams);
        const rawSignedTxn = assetTX.signTxn(flags.creator.sk);
        const txInfo = await this.algodClient.sendRawTransaction(rawSignedTxn).do();
        const txConfirmation = await this.waitForConfirmation(txInfo.txId);
        const assetIndex = txConfirmation["asset-index"];
        await this.optInToASAMultiple(name, assetIndex, optInAccounts, txParams);
        txWriter.push(message, txConfirmation);
        return {
            creator: flags.creator.addr,
            txId: txInfo.txId,
            assetIndex: assetIndex,
            confirmedRound: txConfirmation[confirmedRound]
        };
    }
    async deployASC(name, scParams, flags, payFlags, txWriter) {
        var _a;
        const message = 'Deploying ASC: ' + name;
        console.log(message);
        const result = await this.ensureCompiled(name, false);
        const programb64 = result.compiled;
        const program = new Uint8Array(Buffer.from(programb64, "base64"));
        const lsig = algosdk_1.default.makeLogicSig(program, scParams);
        const params = await tx.mkSuggestedParams(this.algodClient, payFlags);
        // ASC1 signed by funder
        lsig.sign(flags.funder.sk);
        const funder = flags.funder.addr;
        const contractAddress = lsig.address();
        // Fund smart contract
        console.log("Funding Contract:", contractAddress);
        const closeToRemainder = undefined;
        // Load Note
        let note;
        if ((_a = payFlags.noteb64) !== null && _a !== void 0 ? _a : payFlags.note) {
            note = tx.encodeNote(payFlags.note, payFlags.noteb64);
        }
        const tran = algosdk_1.default.makePaymentTxnWithSuggestedParams(funder, contractAddress, flags.fundingMicroAlgo, closeToRemainder, note, params);
        const signedTxn = tran.signTxn(flags.funder.sk);
        const tranInfo = await this.algodClient.sendRawTransaction(signedTxn).do();
        const confirmedTxn = await this.waitForConfirmation(tranInfo.txId);
        txWriter.push(message, confirmedTxn);
        return {
            creator: flags.funder.addr,
            contractAddress: contractAddress,
            txId: tranInfo.txId,
            logicSignature: lsig,
            confirmedRound: confirmedTxn[confirmedRound]
        };
    }
    async ensureCompiled(name, force) {
        return await this.compileOp.ensureCompiled(name, force);
    }
}
exports.AlgoOperatorImpl = AlgoOperatorImpl;
//# sourceMappingURL=algo-operator.js.map