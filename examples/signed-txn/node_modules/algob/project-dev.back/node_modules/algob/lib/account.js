"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkAccountIndex = exports.validateAccount = exports.loadAccountsFromFileSync = exports.loadAccountsFromFile = exports.mkAccounts = void 0;
const algosdk_1 = require("algosdk");
const fs = __importStar(require("fs"));
const yaml_1 = __importDefault(require("yaml"));
const config_errors_1 = __importDefault(require("../internal/core/config/config-errors"));
const errors_1 = require("../internal/core/errors");
const errors_list_1 = require("../internal/core/errors-list");
function mkAccounts(input) {
    const accounts = [];
    const errs = new config_errors_1.default("");
    let a;
    let idx = 0;
    for (const i of input) {
        ++idx;
        if (i.path) {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.ACCOUNT.HD_ACCOUNT, { path: i.path });
        }
        else if (i.sk) {
            a = i;
        }
        else {
            a = fromMnemonic(i);
        }
        if (validateAccount(a, errs.putter("account_inputs", idx.toString()))) {
            accounts.push(a);
        }
    }
    if (!errs.isEmpty()) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.ACCOUNT.MALFORMED, { errors: errs.toString() });
    }
    return accounts;
}
exports.mkAccounts = mkAccounts;
function fromMnemonic(ia) {
    const a = parseMnemonic(ia.mnemonic);
    if (a.addr !== ia.addr && ia.addr !== "") {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.ACCOUNT.MNEMONIC_ADDR_MISSMATCH, { name: ia.name, addr: ia.addr, mnemonic: ia.mnemonic });
    }
    return { name: ia.name, addr: a.addr, sk: a.sk };
}
function parseMnemonic(mnemonic) {
    try {
        return algosdk_1.mnemonicToSecretKey(mnemonic);
    }
    catch (e) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.ACCOUNT.WRONG_MNEMONIC, { errmsg: e.message }, e.error);
    }
}
function _loadAccounts(content) {
    const parsed = yaml_1.default.parse(content);
    return mkAccounts(parsed);
}
// Loads accounts from `filename`. The file should be a YAML file with list of objects
// which is either `HDAccount`, `MnemonicAccount` or an `Account`.
async function loadAccountsFromFile(filename) {
    return _loadAccounts(await fs.promises.readFile(filename, 'utf8'));
}
exports.loadAccountsFromFile = loadAccountsFromFile;
// Same as `loadAccountsFromFile` but uses sync method instead of async
function loadAccountsFromFileSync(filename) {
    return _loadAccounts(fs.readFileSync(filename, 'utf8'));
}
exports.loadAccountsFromFileSync = loadAccountsFromFileSync;
// returns false if account validation doesn't pass
function validateAccount(a, errs) {
    if (a.addr === "") {
        errs.push("addr", "can't be empty", "string");
    }
    if (!(a.sk && a.sk instanceof Uint8Array && a.sk.length === 64)) {
        errs.push("sk", "Must be an instance of Uint8Array(64)", 'Uint8Array');
    }
    if (!(typeof a.name === 'string' && a.name !== "")) {
        errs.push("name", "can't be empty", 'string');
    }
    return errs.isEmpty;
}
exports.validateAccount = validateAccount;
function mkAccountIndex(accountList) {
    const out = new Map();
    for (const a of accountList) {
        out.set(a.name, a);
    }
    return out;
}
exports.mkAccountIndex = mkAccountIndex;
//# sourceMappingURL=account.js.map