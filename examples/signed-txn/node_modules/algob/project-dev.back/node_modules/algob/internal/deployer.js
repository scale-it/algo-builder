"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgobDeployerReadOnlyImpl = exports.AlgobDeployerImpl = void 0;
const errors_1 = require("./core/errors");
const errors_list_1 = require("./core/errors-list");
// This class is what user interacts with in deploy task
class AlgobDeployerImpl {
    constructor(runtimeEnv, cpData, asaDefs, algoOp, accountsByName, txWriter) {
        this.runtimeEnv = runtimeEnv;
        this.cpData = cpData;
        this.loadedAsaDefs = asaDefs;
        this.algoOp = algoOp;
        this.accounts = runtimeEnv.network.config.accounts;
        this.accountsByName = accountsByName;
        this.txWriter = txWriter;
    }
    get isDeployMode() {
        return true;
    }
    get networkName() {
        return this.runtimeEnv.network.name;
    }
    putMetadata(key, value) {
        const found = this.cpData.getMetadata(this.networkName, key);
        if (found === value) {
            return;
        }
        if (found) {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_METADATA_ALREADY_PRESENT, {
                metadataKey: key
            });
        }
        this.cpData.putMetadata(this.networkName, key, value);
    }
    getMetadata(key) {
        return this.cpData.getMetadata(this.networkName, key);
    }
    assertNoAsset(name) {
        if (this.isDefined(name)) {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_ASSET_ALREADY_PRESENT, {
                assetName: name
            });
        }
    }
    _getASAInfo(name) {
        const found = this.asa.get(name);
        if (!found) {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_ASA_NOT_DEFINED, {
                assetName: name
            });
        }
        return found;
    }
    _getAccount(name) {
        const found = this.accountsByName.get(name);
        if (!found) {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.ACCOUNT_NOT_FOUND, {
                assetName: name
            });
        }
        return found;
    }
    async deployASA(name, flags) {
        if (this.loadedAsaDefs[name] === undefined) {
            throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_ASA_DEF_NOT_FOUND, {
                asaName: name
            });
        }
        this.assertNoAsset(name);
        const asaInfo = await this.algoOp.deployASA(name, this.loadedAsaDefs[name], flags, this.accountsByName, this.txWriter);
        this.cpData.registerASA(this.networkName, name, asaInfo);
        return asaInfo;
    }
    async deployASC(name, scParams, flags, payFlags) {
        this.assertNoAsset(name);
        const ascInfo = await this.algoOp.deployASC(name, scParams, flags, payFlags, this.txWriter);
        this.cpData.registerASC(this.networkName, name, ascInfo);
        return ascInfo;
    }
    isDefined(name) {
        return this.cpData.isDefined(this.networkName, name);
    }
    get asa() {
        var _a, _b;
        return (_b = (_a = this.cpData.precedingCP[this.networkName]) === null || _a === void 0 ? void 0 : _a.asa) !== null && _b !== void 0 ? _b : new Map();
    }
    get asc() {
        var _a, _b;
        return (_b = (_a = this.cpData.precedingCP[this.networkName]) === null || _a === void 0 ? void 0 : _a.asc) !== null && _b !== void 0 ? _b : new Map();
    }
    get algodClient() {
        return this.algoOp.algodClient;
    }
    async waitForConfirmation(txId) {
        return await this.algoOp.waitForConfirmation(txId);
    }
    async optInToASA(name, accountName, flags) {
        await this.algoOp.optInToASA(name, this._getASAInfo(name).assetIndex, this._getAccount(accountName), flags);
    }
    log(msg, obj) {
        this.txWriter.push(msg, obj);
    }
}
exports.AlgobDeployerImpl = AlgobDeployerImpl;
// This class is what user interacts with in run task
class AlgobDeployerReadOnlyImpl {
    constructor(deployer, txWriter) {
        this._internal = deployer;
        this.txWriter = txWriter;
    }
    get accounts() {
        return this._internal.accounts;
    }
    get accountsByName() {
        return this._internal.accountsByName;
    }
    get isDeployMode() {
        return false;
    }
    putMetadata(_key, _value) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "putMetadata"
        });
    }
    getMetadata(key) {
        return this._internal.getMetadata(key);
    }
    async deployASA(_name, _flags) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "deployASA"
        });
    }
    async deployASC(_name, scParams, flags, payFlags) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "deployASC"
        });
    }
    isDefined(name) {
        return this._internal.isDefined(name);
    }
    get asa() {
        return this._internal.asa;
    }
    get asc() {
        return this._internal.asc;
    }
    get algodClient() {
        return this._internal.algodClient;
    }
    async waitForConfirmation(txId) {
        return await this._internal.waitForConfirmation(txId);
    }
    optInToASA(name, accountName, flags) {
        throw new errors_1.BuilderError(errors_list_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "optInToASA"
        });
    }
    log(msg, obj) {
        this.txWriter.push(msg, obj);
    }
}
exports.AlgobDeployerReadOnlyImpl = AlgobDeployerReadOnlyImpl;
//# sourceMappingURL=deployer.js.map